<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2D Topdown Multiplayer Shooter</title>
<style>
  /* Reset and base */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0; height: 100%; overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #111;
    color: #eee;
    user-select: none;
  }
  #login-screen, #lobby-screen, #game-screen, #scoreboard-screen {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #111;
  }
  #login-screen, #lobby-screen, #scoreboard-screen {
    z-index: 10;
  }
  #login-screen.hidden, #lobby-screen.hidden, #game-screen.hidden, #scoreboard-screen.hidden {
    display: none;
  }
  input, button, select {
    font-size: 1rem;
    padding: 0.5em 1em;
    margin: 0.5em;
    border-radius: 6px;
    border: none;
    outline: none;
  }
  input {
    width: 250px;
  }
  button {
    background: #28a745;
    color: white;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  button:hover:not(:disabled) {
    background: #218838;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  select {
    background: #222;
    color: #eee;
  }
  #game-canvas {
    background: #222;
    display: block;
    margin: 0 auto;
    border: 3px solid #444;
    border-radius: 10px;
  }
  #customization-panel {
    position: absolute;
    top: 10px; right: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 10px;
    max-width: 300px;
    color: #eee;
    font-size: 14px;
  }
  #customization-panel label {
    display: block;
    margin-top: 10px;
  }
  #customization-panel input[type=color], #customization-panel select {
    width: 100%;
  }
  #chat-box {
    position: absolute;
    bottom: 10px; left: 10px;
    width: 300px;
    max-height: 200px;
    background: rgba(0,0,0,0.7);
    border-radius: 10px;
    overflow-y: auto;
    padding: 10px;
    font-size: 14px;
  }
  #chat-input {
    width: 300px;
    margin-top: 5px;
    padding: 5px;
    border-radius: 6px;
    border: none;
    outline: none;
  }
  #mode-select {
    margin-top: 1em;
  }
  #map-vote {
    margin-top: 1em;
  }
  #scoreboard {
    position: absolute;
    top: 10px; left: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 10px;
    max-width: 300px;
    font-size: 14px;
    color: #eee;
  }
  #scoreboard h3 {
    margin: 0 0 10px 0;
    font-weight: 700;
    text-align: center;
  }
  #scoreboard table {
    width: 100%;
    border-collapse: collapse;
  }
  #scoreboard th, #scoreboard td {
    padding: 4px 6px;
    border-bottom: 1px solid #444;
    text-align: left;
  }
  #scoreboard th {
    background: #333;
  }
  #scoreboard td.score {
    text-align: right;
  }
  #waves-info {
    position: absolute;
    top: 10px; right: 10px;
    color: #eee;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 10px;
    font-size: 16px;
    font-weight: 700;
  }
</style>
</head>
<body>

<!-- LOGIN SCREEN -->
<div id="login-screen">
  <h1>Welcome to Topdown Shooter</h1>
  <input type="text" id="username-input" placeholder="Enter your username" maxlength="16" autocomplete="off" />
  <button id="login-btn" disabled>Login</button>
  <p style="font-size: 0.9em; color: #888;">Username saved locally</p>
</div>

<!-- LOBBY SCREEN -->
<div id="lobby-screen" class="hidden">
  <h2>Hello, <span id="display-username"></span></h2>
  <div>
    <label for="mode-select">Select Mode:</label>
    <select id="mode-select">
      <option value="1v1">1v1 Duel</option>
      <option value="multiplayer">Multiplayer (Random Lobby)</option>
      <option value="zombies">Zombies (PvE Waves)</option>
    </select>
  </div>
  <div id="map-vote">
    <h3>Map Voting</h3>
    <div id="map-options" style="display:flex;flex-wrap:wrap;justify-content:center;gap:10px;"></div>
    <button id="random-map-btn">Random Map</button>
  </div>
  <button id="start-game-btn" disabled>Start Game</button>
  <button id="logout-btn" style="margin-top:1em; background:#c0392b;">Logout</button>
</div>

<!-- GAME SCREEN -->
<div id="game-screen" class="hidden">
  <canvas id="game-canvas" width="900" height="600" tabindex="0"></canvas>
  <div id="customization-panel">
    <h3>Customization</h3>
    <label for="color-picker">Player Color:</label>
    <input type="color" id="color-picker" value="#00ff00" />
    <label for="hat-select">Hat:</label>
    <select id="hat-select">
      <option value="none">None</option>
      <option value="cap">Cap</option>
      <option value="helmet">Helmet</option>
      <option value="bandana">Bandana</option>
    </select>
    <label for="gun-select">Gun:</label>
    <select id="gun-select">
      <option value="pistol">Pistol</option>
      <option value="rifle">Rifle</option>
      <option value="shotgun">Shotgun</option>
    </select>
    <button id="apply-customization-btn" style="margin-top:10px;">Apply</button>
    <button id="leave-game-btn" style="margin-top:10px; background:#c0392b;">Leave Game</button>
  </div>
  <div id="scoreboard">
    <h3>Scoreboard</h3>
    <table>
      <thead><tr><th>Player</th><th class="score">Score</th></tr></thead>
      <tbody id="scoreboard-body"></tbody>
    </table>
  </div>
  <div id="waves-info" style="display:none;">Wave: 0 | Zombies Left: 0</div>
  <div id="chat-box"></div>
  <input type="text" id="chat-input" placeholder="Type message and press Enter" autocomplete="off" />
</div>

<!-- SCOREBOARD SCREEN (for after game) -->
<div id="scoreboard-screen" class="hidden">
  <h2>Game Over</h2>
  <div id="final-scoreboard"></div>
  <button id="return-lobby-btn">Return to Lobby</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
<script>
(() => {
  // Constants
  const CANVAS_WIDTH = 900;
  const CANVAS_HEIGHT = 600;
  const PLAYER_RADIUS = 15;
  const PLAYER_SPEED = 3.5;
  const BULLET_SPEED = 10;
  const BULLET_RADIUS = 5;
  const ZOMBIE_RADIUS = 18;
  const ZOMBIE_SPEED_BASE = 1.2;
  const WAVE_ZOMBIE_INCREMENT = 3;
  const MAX_UPGRADE_LEVEL = 5;

  // Maps data (10 maps)
  // Each map: array of walls (rectangles), spawn points for players and zombies
  // Walls: {x,y,width,height}
  // Spawn points: {x,y}
  const MAPS = [
    {
      name: "Urban Ruins",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 300, y: 150, width: 300, height: 30},
        {x: 300, y: 420, width: 300, height: 30},
        {x: 150, y: 300, width: 30, height: 150},
        {x: 720, y: 300, width: 30, height: 150},
      ],
      playerSpawns: [{x: 100, y: 100}, {x: 800, y: 500}],
      zombieSpawns: [{x: 450, y: 300}, {x: 450, y: 100}, {x: 450, y: 500}],
    },
    {
      name: "Desert Outpost",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 200, y: 200, width: 500, height: 30},
        {x: 200, y: 370, width: 500, height: 30},
        {x: 200, y: 230, width: 30, height: 140},
        {x: 670, y: 230, width: 30, height: 140},
      ],
      playerSpawns: [{x: 60, y: 300}, {x: 840, y: 300}],
      zombieSpawns: [{x: 450, y: 100}, {x: 450, y: 500}],
    },
    {
      name: "Factory Floor",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 150, y: 150, width: 600, height: 30},
        {x: 150, y: 420, width: 600, height: 30},
        {x: 150, y: 180, width: 30, height: 240},
        {x: 720, y: 180, width: 30, height: 240},
        {x: 400, y: 270, width: 100, height: 60},
      ],
      playerSpawns: [{x: 100, y: 100}, {x: 800, y: 500}],
      zombieSpawns: [{x: 450, y: 300}],
    },
    {
      name: "Forest Clearing",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 250, y: 250, width: 400, height: 100},
        {x: 250, y: 250, width: 30, height: 100},
        {x: 620, y: 250, width: 30, height: 100},
      ],
      playerSpawns: [{x: 100, y: 100}, {x: 800, y: 500}],
      zombieSpawns: [{x: 450, y: 300}],
    },
    {
      name: "Snowy Village",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 350, y: 100, width: 200, height: 30},
        {x: 350, y: 470, width: 200, height: 30},
        {x: 350, y: 130, width: 30, height: 340},
        {x: 520, y: 130, width: 30, height: 340},
      ],
      playerSpawns: [{x: 100, y: 300}, {x: 800, y: 300}],
      zombieSpawns: [{x: 450, y: 300}],
    },
    {
      name: "Industrial Complex",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 200, y: 200, width: 500, height: 30},
        {x: 200, y: 370, width: 500, height: 30},
        {x: 200, y: 230, width: 30, height: 140},
        {x: 670, y: 230, width: 30, height: 140},
        {x: 435, y: 270, width: 30, height: 60},
      ],
      playerSpawns: [{x: 60, y: 300}, {x: 840, y: 300}],
      zombieSpawns: [{x: 450, y: 100}, {x: 450, y: 500}],
    },
    {
      name: "Suburban Streets",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 150, y: 150, width: 30, height: 300},
        {x: 720, y: 150, width: 30, height: 300},
        {x: 150, y: 150, width: 600, height: 30},
        {x: 150, y: 420, width: 600, height: 30},
      ],
      playerSpawns: [{x: 100, y: 100}, {x: 800, y: 500}],
      zombieSpawns: [{x: 450, y: 300}],
    },
    {
      name: "Canyon Pass",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 400, y: 0, width: 30, height: 600},
        {x: 200, y: 270, width: 500, height: 30},
      ],
      playerSpawns: [{x: 100, y: 300}, {x: 800, y: 300}],
      zombieSpawns: [{x: 450, y: 100}, {x: 450, y: 500}],
    },
    {
      name: "Abandoned Mall",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 300, y: 150, width: 300, height: 30},
        {x: 300, y: 420, width: 300, height: 30},
        {x: 300, y: 180, width: 30, height: 240},
        {x: 570, y: 180, width: 30, height: 240},
        {x: 440, y: 270, width: 20, height: 60},
      ],
      playerSpawns: [{x: 100, y: 100}, {x: 800, y: 500}],
      zombieSpawns: [{x: 450, y: 300}],
    },
    {
      name: "Military Base",
      walls: [
        {x: 0, y: 0, width: 900, height: 30},
        {x: 0, y: 570, width: 900, height: 30},
        {x: 0, y: 0, width: 30, height: 600},
        {x: 870, y: 0, width: 30, height: 600},
        {x: 200, y: 200, width: 500, height: 30},
        {x: 200, y: 370, width: 500, height: 30},
        {x: 200, y: 230, width: 30, height: 140},
        {x: 670, y: 230, width: 30, height: 140},
        {x: 435, y: 270, width: 30, height: 60},
      ],
      playerSpawns: [{x: 60, y: 300}, {x: 840, y: 300}],
      zombieSpawns: [{x: 450, y: 100}, {x: 450, y: 500}],
    },
  ];

  // Hats draw functions (simple shapes)
  const HATS = {
    none: (ctx, x, y, radius, color) => {},
    cap: (ctx, x, y, radius, color) => {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x - radius * 0.7, y - radius * 0.9);
      ctx.lineTo(x + radius * 0.7, y - radius * 0.9);
      ctx.lineTo(x + radius * 0.4, y - radius * 1.3);
      ctx.lineTo(x - radius * 0.4, y - radius * 1.3);
      ctx.closePath();
      ctx.fill();
      ctx.fillRect(x - radius * 0.7, y - radius * 0.9, radius * 1.4, radius * 0.3);
    },
    helmet: (ctx, x, y, radius, color) => {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y - radius * 0.7, radius * 0.9, Math.PI, 0, false);
      ctx.fill();
      ctx.fillRect(x - radius * 0.9, y - radius * 0.7, radius * 1.8, radius * 0.3);
    },
    bandana: (ctx, x, y, radius, color) => {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x - radius * 0.9, y - radius * 0.7);
      ctx.lineTo(x + radius * 0.9, y - radius * 0.7);
      ctx.lineTo(x, y - radius * 1.3);
      ctx.closePath();
      ctx.fill();
    },
  };

  // Guns data
  const GUNS = {
    pistol: {fireRate: 400, bulletSpeed: 10, bulletDamage: 20, bulletColor: '#ffff66'},
    rifle: {fireRate: 150, bulletSpeed: 14, bulletDamage: 12, bulletColor: '#66ccff'},
    shotgun: {fireRate: 900, bulletSpeed: 9, bulletDamage: 8, bulletColor: '#ff9966', pellets: 6, spread: 0.4},
  };

  // Utility functions
  function distance(x1, y1, x2, y2) {
    return Math.hypot(x2 - x1, y2 - y1);
  }
  function rectCircleColliding(circle, rect) {
    // circle: {x,y,radius}
    // rect: {x,y,width,height}
    const distX = Math.abs(circle.x - rect.x - rect.width / 2);
    const distY = Math.abs(circle.y - rect.y - rect.height / 2);

    if (distX > (rect.width / 2 + circle.radius)) { return false; }
    if (distY > (rect.height / 2 + circle.radius)) { return false; }

    if (distX <= (rect.width / 2)) { return true; }
    if (distY <= (rect.height / 2)) { return true; }

    const dx = distX - rect.width / 2;
    const dy = distY - rect.height / 2;
    return (dx * dx + dy * dy <= (circle.radius * circle.radius));
  }
  function circleCircleColliding(c1, c2) {
    return distance(c1.x, c1.y, c2.x, c2.y) < (c1.radius + c2.radius);
  }
  function clamp(val, min, max) {
    return Math.min(max, Math.max(min, val));
  }

  // LocalStorage keys
  const STORAGE_KEYS = {
    username: 'tds_username',
    customization: 'tds_customization',
    scores: 'tds_scores',
  };

  // PeerJS setup
  let peer = null;
  let conn = null;
  let peerId = null;
  let connections = new Map(); // peerId -> DataConnection

  // Game State
  let gameState = null;
  let localPlayerId = null;
  let localPlayer = null;
  let players = new Map(); // id -> player object
  let bullets = [];
  let zombies = [];
  let currentMap = null;
  let currentWave = 0;
  let waveInProgress = false;
  let waveZombieCount = 0;
  let waveZombiesLeft = 0;
  let upgrades = {
    damage: 0,
    fireRate: 0,
    speed: 0,
  };

  // Game mode: '1v1', 'multiplayer', 'zombies'
  let gameMode = null;

  // Lobby info
  let lobbyPlayers = [];
  let lobbyId = null;
  let mapVote = null;

  // Username and customization
  let username = '';
  let customization = {
    color: '#00ff00',
    hat: 'none',
    gun: 'pistol',
  };

  // Canvas and context
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');

  // DOM elements
  const loginScreen = document.getElementById('login-screen');
  const lobbyScreen = document.getElementById('lobby-screen');
  const gameScreen = document.getElementById('game-screen');
  const scoreboardScreen = document.getElementById('scoreboard-screen');

  const usernameInput = document.getElementById('username-input');
  const loginBtn = document.getElementById('login-btn');
  const displayUsername = document.getElementById('display-username');
  const modeSelect = document.getElementById('mode-select');
  const mapOptionsDiv = document.getElementById('map-options');
  const randomMapBtn = document.getElementById('random-map-btn');
  const startGameBtn = document.getElementById('start-game-btn');
  const logoutBtn = document.getElementById('logout-btn');

  const colorPicker = document.getElementById('color-picker');
  const hatSelect = document.getElementById('hat-select');
  const gunSelect = document.getElementById('gun-select');
  const applyCustomizationBtn = document.getElementById('apply-customization-btn');
  const leaveGameBtn = document.getElementById('leave-game-btn');

  const scoreboardBody = document.getElementById('scoreboard-body');
  const finalScoreboardDiv = document.getElementById('final-scoreboard');
  const returnLobbyBtn = document.getElementById('return-lobby-btn');

  const chatBox = document.getElementById('chat-box');
  const chatInput = document.getElementById('chat-input');

  const wavesInfo = document.getElementById('waves-info');

  // Input state
  const keysPressed = {};
  let mousePos = {x: 0, y: 0};
  let mouseDown = false;

  // Timing
  let lastFireTime = 0;

  // Scoreboard data
  let scores = {}; // username -> score

  // Account sync (simulate with localStorage + Cloudflare Functions)
  // We'll implement a minimal fetch-based scoreboard sync with CF functions

  // Cloudflare Functions endpoints (you must deploy these on your CF Pages backend)
  // For demonstration, these URLs are placeholders
  const CF_API_BASE = '/.netlify/functions'; // Replace with your CF functions base path if needed
  // We'll assume endpoints:
  // POST /scoreboard/save {username, score, customization}
  // GET /scoreboard/top

  // ========== Initialization ==========

  function loadLocalData() {
    const storedUsername = localStorage.getItem(STORAGE_KEYS.username);
    if (storedUsername) {
      username = storedUsername;
      usernameInput.value = username;
      loginBtn.disabled = false;
    }
    const storedCustomization = localStorage.getItem(STORAGE_KEYS.customization);
    if (storedCustomization) {
      try {
        customization = JSON.parse(storedCustomization);
      } catch {}
    }
  }

  function saveLocalData() {
    localStorage.setItem(STORAGE_KEYS.username, username);
    localStorage.setItem(STORAGE_KEYS.customization, JSON.stringify(customization));
  }

  // ========== UI Handlers ==========

  usernameInput.addEventListener('input', () => {
    loginBtn.disabled = usernameInput.value.trim().length < 3;
  });

  loginBtn.addEventListener('click', () => {
    username = usernameInput.value.trim();
    if (username.length < 3) return;
    saveLocalData();
    enterLobby();
  });

  logoutBtn.addEventListener('click', () => {
    localStorage.removeItem(STORAGE_KEYS.username);
    localStorage.removeItem(STORAGE_KEYS.customization);
    location.reload();
  });

  modeSelect.addEventListener('change', () => {
    updateStartButtonState();
  });

  randomMapBtn.addEventListener('click', () => {
    const randomIndex = Math.floor(Math.random() * MAPS.length);
    selectMap(randomIndex);
  });

  startGameBtn.addEventListener('click', () => {
    if (!mapVote) return;
    gameMode = modeSelect.value;
    startGame();
  });

  applyCustomizationBtn.addEventListener('click', () => {
    customization.color = colorPicker.value;
    customization.hat = hatSelect.value;
    customization.gun = gunSelect.value;
    saveLocalData();
    if (localPlayer) {
      localPlayer.color = customization.color;
      localPlayer.hat = customization.hat;
      localPlayer.gun = customization.gun;
      sendPlayerUpdate();
    }
  });

  leaveGameBtn.addEventListener('click', () => {
    leaveGame();
  });

  returnLobbyBtn.addEventListener('click', () => {
    scoreboardScreen.classList.add('hidden');
    lobbyScreen.classList.remove('hidden');
  });

  chatInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && chatInput.value.trim()) {
      sendChatMessage(chatInput.value.trim());
      chatInput.value = '';
    }
  });

  // ========== Lobby Map Voting UI ==========

  function createMapOption(index, map) {
    const div = document.createElement('div');
    div.style.width = '120px';
    div.style.height = '80px';
    div.style.border = '2px solid #666';
    div.style.borderRadius = '8px';
    div.style.cursor = 'pointer';
    div.style.background = '#222';
    div.style.color = '#eee';
    div.style.display = 'flex';
    div.style.flexDirection = 'column';
    div.style.justifyContent = 'center';
    div.style.alignItems = 'center';
    div.style.userSelect = 'none';
    div.textContent = map.name;
    div.title = map.name;

    div.addEventListener('click', () => {
      selectMap(index);
    });

    return div;
  }

  function updateMapOptions() {
    mapOptionsDiv.innerHTML = '';
    MAPS.forEach((map, i) => {
      const option = createMapOption(i, map);
      mapOptionsDiv.appendChild(option);
    });
  }

  function selectMap(index) {
    mapVote = index;
    Array.from(mapOptionsDiv.children).forEach((child, i) => {
      child.style.borderColor = (i === index) ? '#28a745' : '#666';
      child.style.background = (i === index) ? '#144214' : '#222';
    });
    updateStartButtonState();
  }

  function updateStartButtonState() {
    startGameBtn.disabled = mapVote === null || !modeSelect.value;
  }

  // ========== PeerJS and Networking ==========

  // We will implement a simple signaling server via PeerJS cloud server
  // For multiplayer mode, we randomly pair players by connecting to a lobby peer ID
  // For 1v1, connect directly to opponent peer ID
  // For zombies mode, single player or multiplayer with zombies AI spawned locally and synced

  // To keep it manageable, we will:
  // - Use PeerJS to create a peer with ID = username + random suffix
  // - For 1v1 and multiplayer, connect to a "matchmaker" peer that pairs players
  // - For zombies mode, players connect to a lobby and sync zombies state

  // Matchmaker peer ID (Cloudflare Functions or external server recommended)
  // For this demo, we simulate matchmaker with a fixed peer ID "matchmaker"
  // In production, you would implement a CF function or server to handle matchmaking

  const MATCHMAKER_PEER_ID = 'matchmaker';

  // Initialize PeerJS
  function initPeer() {
    peer = new Peer(username + '-' + Math.floor(Math.random() * 10000), {
      debug: 0,
    });

    peer.on('open', id => {
      peerId = id;
      console.log('Peer connected with ID:', id);
      connectToMatchmaker();
    });

    peer.on('connection', c => {
      c.on('open', () => {
        console.log('Incoming connection from:', c.peer);
        connections.set(c.peer, c);
        setupConnection(c);
      });
    });

    peer.on('error', err => {
      console.error('Peer error:', err);
      alert('Connection error: ' + err);
    });
  }

  // Connect to matchmaker peer
  let matchmakerConn = null;
  function connectToMatchmaker() {
    if (peer.destroyed) return;
    if (matchmakerConn && matchmakerConn.open) return;

    matchmakerConn = peer.connect(MATCHMAKER_PEER_ID, { reliable: true });
    matchmakerConn.on('open', () => {
      console.log('Connected to matchmaker');
      matchmakerConn.send({ type: 'register', username, peerId });
    });
    matchmakerConn.on('data', data => {
      handleMatchmakerMessage(data);
    });
    matchmakerConn.on('close', () => {
      console.log('Matchmaker connection closed');
      setTimeout(connectToMatchmaker, 3000);
    });
    matchmakerConn.on('error', err => {
      console.error('Matchmaker connection error:', err);
    });
  }

  // Handle messages from matchmaker
  function handleMatchmakerMessage(data) {
    if (!data || !data.type) return;
    switch(data.type) {
      case 'lobby-assigned':
        lobbyId = data.lobbyId;
        lobbyPlayers = data.players;
        console.log('Assigned to lobby:', lobbyId, lobbyPlayers);
        // Connect to other players in lobby
        data.players.forEach(p => {
          if (p.peerId !== peerId && !connections.has(p.peerId)) {
            connectToPeer(p.peerId);
          }
        });
        break;
      case 'player-joined':
        if (!lobbyPlayers.find(p => p.peerId === data.player.peerId)) {
          lobbyPlayers.push(data.player);
          connectToPeer(data.player.peerId);
        }
        break;
      case 'player-left':
        lobbyPlayers = lobbyPlayers.filter(p => p.peerId !== data.peerId);
        if (connections.has(data.peerId)) {
          connections.get(data.peerId).close();
          connections.delete(data.peerId);
        }
        break;
      case 'start-game':
        if (data.lobbyId === lobbyId) {
          // Start game with given mode and map
          gameMode = data.mode;
          mapVote = data.mapIndex;
          startGame();
        }
        break;
      default:
        console.log('Unknown matchmaker message:', data);
    }
  }

  // Connect to a peer
  function connectToPeer(peerIdToConnect) {
    if (connections.has(peerIdToConnect)) return;
    const c = peer.connect(peerIdToConnect, { reliable: true });
    c.on('open', () => {
      console.log('Connected to peer:', peerIdToConnect);
      connections.set(peerIdToConnect, c);
      setupConnection(c);
      // Send initial player info
      sendPlayerUpdate(c);
    });
    c.on('data', data => {
      handlePeerData(peerIdToConnect, data);
    });
    c.on('close', () => {
      console.log('Connection closed:', peerIdToConnect);
      connections.delete(peerIdToConnect);
      players.delete(peerIdToConnect);
    });
    c.on('error', err => {
      console.error('Connection error with', peerIdToConnect, err);
    });
  }

  // Setup connection event handlers
  function setupConnection(connection) {
    connection.on('data', data => {
      handlePeerData(connection.peer, data);
    });
    connection.on('close', () => {
      console.log('Connection closed:', connection.peer);
      connections.delete(connection.peer);
      players.delete(connection.peer);
    });
  }

  // Send player update to all peers
  function sendPlayerUpdate(targetConn) {
    if (!localPlayer) return;
    const data = {
      type: 'player-update',
      id: localPlayerId,
      username,
      x: localPlayer.x,
      y: localPlayer.y,
      angle: localPlayer.angle,
      color: customization.color,
      hat: customization.hat,
      gun: customization.gun,
      score: localPlayer.score,
      upgrades,
    };
    if (targetConn) {
      if (targetConn.open) targetConn.send(data);
    } else {
      connections.forEach(c => {
        if (c.open) c.send(data);
      });
    }
  }

  // Send bullet fired event
  function sendBulletFired(bullet) {
    const data = {
      type: 'bullet-fired',
      id: bullet.id,
      x: bullet.x,
      y: bullet.y,
      angle: bullet.angle,
      speed: bullet.speed,
      ownerId: bullet.ownerId,
      gun: bullet.gun,
    };
    connections.forEach(c => {
      if (c.open) c.send(data);
    });
  }

  // Send chat message
  function sendChatMessage(text) {
    const data = {
      type: 'chat-message',
      username,
      text,
    };
    appendChatMessage(username, text);
    connections.forEach(c => {
      if (c.open) c.send(data);
    });
  }

  // Handle incoming peer data
  function handlePeerData(peerIdFrom, data) {
    if (!data || !data.type) return;
    switch(data.type) {
      case 'player-update':
        if (!players.has(data.id)) {
          players.set(data.id, {
            id: data.id,
            username: data.username,
            x: data.x,
            y: data.y,
            angle: data.angle,
            color: data.color,
            hat: data.hat,
            gun: data.gun,
            score: data.score || 0,
            upgrades: data.upgrades || {damage:0,fireRate:0,speed:0},
          });
        } else {
          const p = players.get(data.id);
          p.x = data.x;
          p.y = data.y;
          p.angle = data.angle;
          p.color = data.color;
          p.hat = data.hat;
          p.gun = data.gun;
          p.score = data.score || 0;
          p.upgrades = data.upgrades || p.upgrades;
        }
        break;
      case 'bullet-fired':
        if (!bullets.find(b => b.id === data.id)) {
          bullets.push({
            id: data.id,
            x: data.x,
            y: data.y,
            angle: data.angle,
            speed: data.speed,
            ownerId: data.ownerId,
            gun: data.gun,
            radius: BULLET_RADIUS,
          });
        }
        break;
      case 'chat-message':
        appendChatMessage(data.username, data.text);
        break;
      case 'upgrade-purchased':
        if (players.has(data.playerId)) {
          players.get(data.playerId).upgrades = data.upgrades;
        }
        break;
      default:
        console.log('Unknown peer data type:', data.type);
    }
  }

  // Append chat message to chat box
  function appendChatMessage(user, text) {
    const div = document.createElement('div');
    div.innerHTML = `<strong>${escapeHtml(user)}:</strong> ${escapeHtml(text)}`;
    chatBox.appendChild(div);
    chatBox.scrollTop = chatBox.scrollHeight;
  }
  function escapeHtml(text) {
    return text.replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
    })[m]);
  }

  // ========== Game Logic ==========

  // Player class
  class Player {
    constructor(id, username, x, y, color, hat, gun) {
      this.id = id;
      this.username = username;
      this.x = x;
      this.y = y;
      this.color = color;
      this.hat = hat;
      this.gun = gun;
      this.angle = 0;
      this.radius = PLAYER_RADIUS;
      this.speed = PLAYER_SPEED;
      this.score = 0;
      this.health = 100;
      this.maxHealth = 100;
      this.upgrades = {damage:0, fireRate:0, speed:0};
      this.lastFire = 0;
    }
    move(dx, dy, walls) {
      let newX = this.x + dx;
      let newY = this.y + dy;
      // Collision with walls
      const circle = {x: newX, y: newY, radius: this.radius};
      for (const wall of walls) {
        if (rectCircleColliding(circle, wall)) {
          // Try axis separation
          const circleX = {x: newX, y: this.y, radius: this.radius};
          const circleY = {x: this.x, y: newY, radius: this.radius};
          if (!rectCircleColliding(circleX, wall)) {
            this.x = newX;
          }
          if (!rectCircleColliding(circleY, wall)) {
            this.y = newY;
          }
          return;
        }
      }
      this.x = newX;
      this.y = newY;
    }
    draw(ctx) {
      // Body
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();

      // Gun direction
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      const gunLength = this.radius + 15;
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x + Math.cos(this.angle) * gunLength, this.y + Math.sin(this.angle) * gunLength);
      ctx.stroke();

      // Hat
      if (HATS[this.hat]) {
        HATS[this.hat](ctx, this.x, this.y, this.radius, '#222');
      }

      // Health bar
      ctx.fillStyle = 'red';
      ctx.fillRect(this.x - this.radius, this.y + this.radius + 5, this.radius * 2, 5);
      ctx.fillStyle = 'limegreen';
      ctx.fillRect(this.x - this.radius, this.y + this.radius + 5, this.radius * 2 * (this.health / this.maxHealth), 5);

      // Username
      ctx.fillStyle = '#eee';
      ctx.font = '12px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText(this.username, this.x, this.y - this.radius - 10);
    }
  }

  // Bullet class
  class Bullet {
    constructor(id, x, y, angle, speed, ownerId, gun) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.angle = angle;
      this.speed = speed;
      this.ownerId = ownerId;
      this.gun = gun;
      this.radius = BULLET_RADIUS;
      this.life = 2000; // ms
      this.spawnTime = performance.now();
    }
    update(delta, walls) {
      const dx = Math.cos(this.angle) * this.speed;
      const dy = Math.sin(this.angle) * this.speed;
      let newX = this.x + dx;
      let newY = this.y + dy;
      // Check collision with walls
      const circle = {x: newX, y: newY, radius: this.radius};
      for (const wall of walls) {
        if (rectCircleColliding(circle, wall)) {
          return false; // bullet destroyed
        }
      }
      this.x = newX;
      this.y = newY;
      if (performance.now() - this.spawnTime > this.life) {
        return false;
      }
      return true;
    }
    draw(ctx) {
      const gunData = GUNS[this.gun] || GUNS.pistol;
      ctx.fillStyle = gunData.bulletColor;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Zombie class
  class Zombie {
    constructor(id, x, y, speed) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.radius = ZOMBIE_RADIUS;
      this.speed = speed;
      this.health = 50;
      this.maxHealth = 50;
      this.targetId = null;
      this.isDead = false;
    }
    update(delta, players, walls) {
      if (this.isDead) return;
      // Find nearest player
      let targetPlayer = null;
      let minDist = 99999;
      players.forEach(p => {
        if (p.health <= 0) return;
        const dist = distance(this.x, this.y, p.x, p.y);
        if (dist < minDist) {
          minDist = dist;
          targetPlayer = p;
          this.targetId = p.id;
        }
      });
      if (!targetPlayer) return;
      // Move toward player
      const angle = Math.atan2(targetPlayer.y - this.y, targetPlayer.x - this.x);
      const dx = Math.cos(angle) * this.speed;
      const dy = Math.sin(angle) * this.speed;
      let newX = this.x + dx;
      let newY = this.y + dy;
      // Collision with walls
      const circle = {x: newX, y: newY, radius: this.radius};
      for (const wall of walls) {
        if (rectCircleColliding(circle, wall)) {
          // Try axis separation
          const circleX = {x: newX, y: this.y, radius: this.radius};
          const circleY = {x: this.x, y: newY, radius: this.radius};
          if (!rectCircleColliding(circleX, wall)) {
            this.x = newX;
          }
          if (!rectCircleColliding(circleY, wall)) {
            this.y = newY;
          }
          return;
        }
      }
      this.x = newX;
      this.y = newY;

      // Attack player if close
      if (distance(this.x, this.y, targetPlayer.x, targetPlayer.y) < this.radius + targetPlayer.radius) {
        targetPlayer.health -= 0.5 * delta;
        if (targetPlayer.health < 0) targetPlayer.health = 0;
      }
    }
    draw(ctx) {
      if (this.isDead) return;
      ctx.fillStyle = '#aa0000';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      // Health bar
      ctx.fillStyle = 'red';
      ctx.fillRect(this.x - this.radius, this.y + this.radius + 5, this.radius * 2, 5);
      ctx.fillStyle = 'limegreen';
      ctx.fillRect(this.x - this.radius, this.y + this.radius + 5, this.radius * 2 * (this.health / this.maxHealth), 5);
    }
  }

  // ========== Game Loop ==========

  let lastFrameTime = performance.now();

  function gameLoop() {
    const now = performance.now();
    const delta = (now - lastFrameTime) / 16.666; // ~60fps base
    lastFrameTime = now;

    if (localPlayer && currentMap) {
      updateGame(delta);
      drawGame();
    }

    requestAnimationFrame(gameLoop);
  }

  // Update game state
  function updateGame(delta) {
    // Handle player input
    let dx = 0, dy = 0;
    if (keysPressed['w'] || keysPressed['ArrowUp']) dy -= 1;
    if (keysPressed['s'] || keysPressed['ArrowDown']) dy += 1;
    if (keysPressed['a'] || keysPressed['ArrowLeft']) dx -= 1;
    if (keysPressed['d'] || keysPressed['ArrowRight']) dx += 1;
    if (dx !== 0 || dy !== 0) {
      const len = Math.sqrt(dx*dx + dy*dy);
      dx /= len;
      dy /= len;
      const speed = localPlayer.speed * (1 + 0.1 * localPlayer.upgrades.speed);
      localPlayer.move(dx * speed * delta, dy * speed * delta, currentMap.walls);
    }

    // Update player angle to mouse
    const rect = canvas.getBoundingClientRect();
    const mouseX = mousePos.x - rect.left;
    const mouseY = mousePos.y - rect.top;
    localPlayer.angle = Math.atan2(mouseY - localPlayer.y, mouseX - localPlayer.x);

    // Fire bullets if mouse down and fire rate allows
    const nowTime = performance.now();
    const gunData = GUNS[localPlayer.gun] || GUNS.pistol;
    const fireRateMod = 1 - 0.1 * localPlayer.upgrades.fireRate;
    if (mouseDown && nowTime - localPlayer.lastFire > gunData.fireRate * fireRateMod) {
      fireBullet(localPlayer);
      localPlayer.lastFire = nowTime;
    }

    // Update bullets
    bullets = bullets.filter(bullet => {
      const alive = bullet.update(delta, currentMap.walls);
      if (!alive) return false;
      // Check collision with zombies and players
      if (gameMode === 'zombies') {
        for (const zombie of zombies) {
          if (zombie.isDead) continue;
          if (circleCircleColliding(bullet, zombie)) {
            zombie.health -= (gunData.bulletDamage || 10) * (1 + 0.2 * localPlayer.upgrades.damage);
            if (zombie.health <= 0) {
              zombie.isDead = true;
              localPlayer.score += 10;
              updateScore(localPlayer.username, localPlayer.score);
            }
            return false;
          }
        }
      } else {
        // PvP mode - check collision with other players
        players.forEach(p => {
          if (p.id === localPlayerId) return;
          if (circleCircleColliding(bullet, p)) {
            p.health -= (gunData.bulletDamage || 10) * (1 + 0.2 * localPlayer.upgrades.damage);
            if (p.health <= 0) {
              p.health = 0;
              localPlayer.score += 20;
              updateScore(localPlayer.username, localPlayer.score);
            }
            return false;
          }
        });
      }
      return true;
    });

    // Update zombies
    if (gameMode === 'zombies') {
      zombies.forEach(zombie => {
        zombie.update(delta, players, currentMap.walls);
        if (zombie.isDead) waveZombiesLeft--;
      });
      if (waveInProgress && waveZombiesLeft <= 0) {
        waveInProgress = false;
        setTimeout(() => {
          startNextWave();
        }, 5000);
      }
    }

    // Update players from connections (positions updated on peer messages)
    // Remove dead players from map
    players.forEach(p => {
      if (p.health <= 0) {
        players.delete(p.id);
      }
    });

    // Send local player update to peers
    sendPlayerUpdate();
  }

  // Draw game state
  function drawGame() {
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw map walls
    ctx.fillStyle = '#444';
    currentMap.walls.forEach(wall => {
      ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
    });

    // Draw zombies
    zombies.forEach(zombie => {
      zombie.draw(ctx);
    });

    // Draw bullets
    bullets.forEach(bullet => {
      bullet.draw(ctx);
    });

    // Draw players
    players.forEach(p => {
      p.draw(ctx);
    });

    // Draw local player on top
    if (localPlayer) {
      localPlayer.draw(ctx);
    }

    // Update scoreboard
    updateScoreboardUI();

    // Update waves info
    if (gameMode === 'zombies') {
      wavesInfo.style.display = 'block';
      wavesInfo.textContent = `Wave: ${currentWave} | Zombies Left: ${waveZombiesLeft}`;
    } else {
      wavesInfo.style.display = 'none';
    }
  }

  // Fire bullet from player
  function fireBullet(player) {
    const gunData = GUNS[player.gun] || GUNS.pistol;
    if (player.gun === 'shotgun') {
      // Fire multiple pellets with spread
      for (let i = 0; i < gunData.pellets; i++) {
        const spreadAngle = player.angle + (Math.random() - 0.5) * gunData.spread;
        const bulletId = player.id + '-' + performance.now() + '-' + i;
        const bullet = new Bullet(bulletId, player.x + Math.cos(spreadAngle) * player.radius, player.y + Math.sin(spreadAngle) * player.radius, spreadAngle, gunData.bulletSpeed, player.id, player.gun);
        bullets.push(bullet);
        sendBulletFired(bullet);
      }
    } else {
      const bulletId = player.id + '-' + performance.now();
      const bullet = new Bullet(bulletId, player.x + Math.cos(player.angle) * player.radius, player.y + Math.sin(player.angle) * player.radius, player.angle, gunData.bulletSpeed, player.id, player.gun);
      bullets.push(bullet);
      sendBulletFired(bullet);
    }
  }

  // Update scoreboard UI
  function updateScoreboardUI() {
    const allPlayers = Array.from(players.values());
    if (localPlayer) allPlayers.push(localPlayer);
    allPlayers.sort((a,b) => b.score - a.score);
    scoreboardBody.innerHTML = '';
    allPlayers.forEach(p => {
      const tr = document.createElement('tr');
      const tdName = document.createElement('td');
      tdName.textContent = p.username;
      const tdScore = document.createElement('td');
      tdScore.textContent = Math.floor(p.score);
      tdScore.classList.add('score');
      tr.appendChild(tdName);
      tr.appendChild(tdScore);
      scoreboardBody.appendChild(tr);
    });
  }

  // Update score locally and sync to server
  function updateScore(username, score) {
    scores[username] = score;
    saveScoresToServer();
  }

  // Save scores to server (Cloudflare function)
  async function saveScoresToServer() {
    try {
      await fetch('/api/saveScore', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          username,
          score: scores[username] || 0,
          customization,
        }),
      });
    } catch (e) {
      console.warn('Failed to save score to server:', e);
    }
  }

  // ========== Game Start/Stop ==========

  function enterLobby() {
    loginScreen.classList.add('hidden');
    lobbyScreen.classList.remove('hidden');
    displayUsername.textContent = username;
    updateMapOptions();
    selectMap(0);
    initPeer();
  }

  function startGame() {
    lobbyScreen.classList.add('hidden');
    gameScreen.classList.remove('hidden');
    canvas.focus();

    // Setup local player
    localPlayerId = peerId;
    const spawn = currentMap ? currentMap.playerSpawns[0] : {x: CANVAS_WIDTH/2, y: CANVAS_HEIGHT/2};
    localPlayer = new Player(localPlayerId, username, spawn.x, spawn.y, customization.color, customization.hat, customization.gun);
    players.clear();
    players.set(localPlayerId, localPlayer);

    bullets = [];
    zombies = [];
    currentWave = 0;
    waveInProgress = false;
    waveZombieCount = 0;
    waveZombiesLeft = 0;
    upgrades = {damage:0, fireRate:0, speed:0};

    // Set current map
    currentMap = MAPS[mapVote];

    if (gameMode === 'zombies') {
      startNextWave();
    }

    lastFrameTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  function leaveGame() {
    gameScreen.classList.add('hidden');
    lobbyScreen.classList.remove('hidden');
    localPlayer = null;
    players.clear();
    bullets = [];
    zombies = [];
    currentWave = 0;
    waveInProgress = false;
    waveZombieCount = 0;
    waveZombiesLeft = 0;
    upgrades = {damage:0, fireRate:0, speed:0};
  }

  // ========== Waves and Zombies ==========

  function startNextWave() {
    currentWave++;
    waveInProgress = true;
    waveZombieCount = currentWave * WAVE_ZOMBIE_INCREMENT;
    waveZombiesLeft = waveZombieCount;

    // Spawn zombies randomly on spawn points
    zombies = [];
    for (let i = 0; i < waveZombieCount; i++) {
      const spawnPoint = currentMap.zombieSpawns[i % currentMap.zombieSpawns.length];
      const speed = ZOMBIE_SPEED_BASE + currentWave * 0.1;
      const zombie = new Zombie('zombie-' + i + '-' + performance.now(), spawnPoint.x + (Math.random() - 0.5) * 40, spawnPoint.y + (Math.random() - 0.5) * 40, speed);
      zombies.push(zombie);
    }
  }

  // ========== Input Handling ==========

  window.addEventListener('keydown', e => {
    keysPressed[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keysPressed[e.key.toLowerCase()] = false;
  });
  canvas.addEventListener('mousemove', e => {
    mousePos.x = e.clientX;
    mousePos.y = e.clientY;
  });
  canvas.addEventListener('mousedown', e => {
    mouseDown = true;
  });
  canvas.addEventListener('mouseup', e => {
    mouseDown = false;
  });
  canvas.addEventListener('blur', e => {
    mouseDown = false;
  });

  // ========== Initialization ==========

  loadLocalData();
  updateStartButtonState();

  // ========== Cloudflare Functions API Mock ==========

  // For demo purposes, we mock the saveScore API on client side
  // Replace this with actual CF function endpoints in production

  window.fetch = (originalFetch => {
    return function(input, init) {
      if (typeof input === 'string' && input.endsWith('/api/saveScore')) {
        // Save score locally (simulate server)
        try {
          const body = JSON.parse(init.body);
          const serverScores = JSON.parse(localStorage.getItem('tds_server_scores') || '{}');
          if (!serverScores[body.username] || serverScores[body.username] < body.score) {
            serverScores[body.username] = body.score;
            localStorage.setItem('tds_server_scores', JSON.stringify(serverScores));
          }
          return Promise.resolve(new Response(JSON.stringify({success:true}), {status:200}));
        } catch(e) {
          return Promise.reject(e);
        }
      }
      return originalFetch(input, init);
    };
  })(window.fetch);

})();
</script>

</body>
</html>
